from magpie.api.api_except import raise_http
from magpie.api import api_rest_schemas as s
from magpie.definitions.pyramid_definitions import (
    IAuthenticationPolicy,
    Authenticated,
    PredicateMismatch,
    HTTPUnauthorized,
    HTTPForbidden,
    HTTPNotFound,
    HTTPMethodNotAllowed,
    HTTPInternalServerError,
    HTTPServerError,
)
from magpie.utils import get_header, CONTENT_TYPE_JSON
from simplejson import JSONDecodeError


def internal_server_error(request):
    content = get_request_info(request, default_message=s.InternalServerErrorResponseSchema.description)
    return raise_http(nothrow=True, httpError=HTTPInternalServerError, detail=content["detail"], content=content,
                      contentType=get_header("Accept", request.headers, default=CONTENT_TYPE_JSON, split=";,"))


def not_found_or_method_not_allowed(request):
    """
    Overrides the default is HTTPNotFound [404] by appropriate HTTPMethodNotAllowed [405] when applicable.

    Not found response can correspond to underlying process operation not finding a required item, or a completely
    unknown route (path did not match any existing API definition).
    Method not allowed is more specific to the case where the path matches an existing API route, but the specific
    request method (GET, POST, etc.) is not allowed on this path.

    Without this fix, both situations return [404] regardless.
    """
    # noinspection PyProtectedMember
    if isinstance(request.exception, PredicateMismatch) and request.method not in request.exception._safe_methods:
        http_err = HTTPMethodNotAllowed
        http_msg = ''   # auto-generated by HTTPMethodNotAllowed
    else:
        http_err = HTTPNotFound
        http_msg = s.NotFoundResponseSchema.description
    content = get_request_info(request, default_message=http_msg)
    return raise_http(nothrow=True, httpError=http_err, detail=content["detail"], content=content,
                      contentType=get_header("Accept", request.headers, default=CONTENT_TYPE_JSON, split=";,"))


def unauthorized_or_forbidden(request):
    """
    Overrides the default is HTTPForbidden [403] by appropriate HTTPUnauthorized [401] when applicable.

    Unauthorized response is for restricted user access according to credentials and/or authorization headers.
    Forbidden response is for operation refused by the underlying process operations.

    Without this fix, both situations return [403] regardless.

    .. seealso::
        http://www.restapitutorial.com/httpstatuscodes.html
    """
    authn_policy = request.registry.queryUtility(IAuthenticationPolicy)
    http_err = HTTPForbidden
    http_msg = s.HTTPForbiddenResponseSchema.description
    if authn_policy:
        principals = authn_policy.effective_principals(request)
        if Authenticated not in principals:
            http_err = HTTPUnauthorized
            http_msg = s.UnauthorizedResponseSchema.description
    content = get_request_info(request, default_message=http_msg)

    return raise_http(nothrow=True, httpError=http_err, detail=content["detail"], content=content,
                      contentType=get_header("Accept", request.headers, default=CONTENT_TYPE_JSON, split=";,"))


def get_request_info(request, default_message="undefined"):
    content = {
        u"route_name": str(request.upath_info),
        u"request_url": str(request.url),
        u"detail": default_message,
        u"method": request.method
    }
    if hasattr(request, "exception"):
        # handle error raised simply by checking for "json" property in python 3 when body is invalid
        has_json = False
        try:
            has_json = hasattr(request.exception, "json")
        except JSONDecodeError:
            pass
        if has_json and isinstance(request.exception.json, dict):
            content.update(request.exception.json)
        elif isinstance(request.exception, HTTPServerError) and hasattr(request.exception, "message"):
            content.update({u"exception": str(request.exception.message)})
        if not content[u"detail"]:
            content[u"detail"] = str(request.exception)
    elif hasattr(request, "matchdict"):
        if request.matchdict is not None and request.matchdict != "":
            content.update(request.matchdict)
    return content
