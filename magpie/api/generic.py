from typing import TYPE_CHECKING

from pyramid.authentication import Authenticated
from pyramid.exceptions import PredicateMismatch
from pyramid.httpexceptions import (
    HTTPForbidden,
    HTTPInternalServerError,
    HTTPMethodNotAllowed,
    HTTPNotAcceptable,
    HTTPNotFound,
    HTTPServerError,
    HTTPUnauthorized
)
from pyramid.request import Request
from simplejson import JSONDecodeError

from magpie.api import schemas as s
from magpie.api.exception import raise_http, verify_param
from magpie.api.requests import get_principals
from magpie.ui.utils import request_api
from magpie.utils import (
    CONTENT_TYPE_ANY,
    CONTENT_TYPE_JSON,
    SUPPORTED_CONTENT_TYPES,
    get_header,
    get_logger,
    get_magpie_url
)

if TYPE_CHECKING:
    # pylint: disable=W0611,unused-import
    from typing import Callable  # noqa: F401
    from magpie.typedefs import Str, JSON  # noqa: F401
    from pyramid.registry import Registry  # noqa: F401
    from pyramid.response import Response  # noqa: F401
    from pyramid.httpexceptions import HTTPException  # noqa: F401
LOGGER = get_logger(__name__)


def internal_server_error(request):
    # type: (Request) -> HTTPException
    """
    Overrides default HTTP.
    """
    content = get_request_info(request, exception_details=True,
                               default_message=s.InternalServerErrorResponseSchema.description)
    return raise_http(nothrow=True, http_error=HTTPInternalServerError, detail=content["detail"], content=content,
                      content_type=get_header("Accept", request.headers, default=CONTENT_TYPE_JSON, split=";,"))


def not_found_or_method_not_allowed(request):
    # type: (Request) -> HTTPException
    """
    Overrides the default ``HTTPNotFound`` [404] by appropriate ``HTTPMethodNotAllowed`` [405] when applicable.

    Not found response can correspond to underlying process operation not finding a required item, or a completely
    unknown route (path did not match any existing API definition).
    Method not allowed is more specific to the case where the path matches an existing API route, but the specific
    request method (GET, POST, etc.) is not allowed on this path.

    Without this fix, both situations return [404] regardless.
    """
    if (isinstance(request.exception, PredicateMismatch)
        and request.method not in request.exception._safe_methods   # pylint: disable=W0212  # noqa: W0212
    ):
        http_err = HTTPMethodNotAllowed
        http_msg = ""   # auto-generated by HTTPMethodNotAllowed
    else:
        http_err = HTTPNotFound
        http_msg = s.NotFoundResponseSchema.description
    content = get_request_info(request, default_message=http_msg)
    return raise_http(nothrow=True, http_error=http_err, detail=content["detail"], content=content,
                      content_type=get_header("Accept", request.headers, default=CONTENT_TYPE_JSON, split=";,"))


def unauthorized_or_forbidden(request):
    # type: (Request) -> HTTPException
    """
    Overrides the default ``HTTPForbidden`` [403] by appropriate ``HTTPUnauthorized`` [401] when applicable.

    Unauthorized response is for restricted user access according to missing credentials and/or authorization headers.
    Forbidden response is for operation refused by the underlying process operations or due to insufficient permissions.

    Without this fix, both situations return [403] regardless.

    .. seealso::
        - http://www.restapitutorial.com/httpstatuscodes.html

    In case the request references to `Magpie UI` route, it is redirected to
    :meth:`magpie.ui.home.HomeViews.error_view` for it to handle and display the error accordingly.
    """
    http_err = HTTPForbidden
    http_msg = s.HTTPForbiddenResponseSchema.description
    principals = get_principals(request)
    if Authenticated not in principals:
        http_err = HTTPUnauthorized
        http_msg = s.UnauthorizedResponseSchema.description
    content = get_request_info(request, default_message=http_msg)
    accept = get_header("Accept", request.headers, default=CONTENT_TYPE_JSON, split=";,")
    if content["route_name"].startswith("/ui") and accept != CONTENT_TYPE_JSON:
        path = request.route_path("error").replace("/magpie", "")
        data = {"error_request": content, "error_code": http_err.code}
        return request_api(request, path, "POST", data)
    return raise_http(nothrow=True, http_error=http_err, detail=content["detail"], content=content, content_type=accept)


def validate_accept_header_tween(handler, registry):    # noqa: F811
    # type: (Callable[[Request], Response], Registry) -> Callable[[Request], Response]
    """
    Tween that validates that the specified request ``Accept`` header (if any) is a supported one by the application.

    :raises HTTPNotAcceptable: if `Accept` header was specified and is not supported.
    """
    def validate_accept_header(request):
        # type: (Request) -> Response
        """
        Validates the specified request according to its ``Accept`` header, ignoring UI related routes that request more
        content-types than the ones supported by the application for display purposes (styles, images etc.).
        """
        # server URL could have more prefixes than only /magpie, so start by removing them using explicit URL setting
        # remove any additional hostname and known /magpie prefix to get only the final magpie-specific path
        magpie_url = get_magpie_url(request)
        magpie_url = request.url.replace(magpie_url, "")
        magpie_path = magpie_url.replace(request.host, "")
        magpie_path = magpie_path.split("/magpie/", 1)[-1]  # make sure we don't split a /magpie(.*) element by mistake
        magpie_path = "/" + magpie_path if not magpie_path.startswith("/") else magpie_path
        # ignore types defined under UI or static routes to allow rendering
        if not any(magpie_path.startswith(p) for p in ("/ui", "/static")):
            any_supported_header = SUPPORTED_CONTENT_TYPES + [CONTENT_TYPE_ANY]
            accept = get_header("accept", request.headers, default=CONTENT_TYPE_JSON, split=";,")
            verify_param(accept, is_in=True, param_compare=any_supported_header, param_name="Accept Header",
                         http_error=HTTPNotAcceptable, msg_on_fail=s.NotAcceptableResponseSchema.description)
        return handler(request)
    return validate_accept_header


def get_request_info(request, default_message="undefined", exception_details=False):
    # type: (Request, Str, bool) -> JSON
    """
    Obtains additional content details about the ``request`` according to available information.
    """
    content = {
        "route_name": str(request.upath_info),
        "request_url": str(request.url),
        "detail": default_message,
        "method": request.method
    }
    if hasattr(request, "exception"):
        # handle error raised simply by checking for "json" property in python 3 when body is invalid
        has_json = False
        try:
            has_json = hasattr(request.exception, "json")
        except JSONDecodeError:
            pass
        if has_json and isinstance(request.exception.json, dict):
            content.update(request.exception.json)
        elif isinstance(request.exception, HTTPServerError) and hasattr(request.exception, "message"):
            content.update({"exception": str(request.exception.message)})
        elif isinstance(request.exception, Exception) and exception_details:
            content.update({"exception": repr(request.exception)})
            # get 'request.exc_info' or 'sys.exc_info', whichever one is available
            LOGGER.error("Request exception.", exc_info=getattr(request, "exc_info", True))
        if not content["detail"]:
            content["detail"] = str(request.exception)
    elif hasattr(request, "matchdict"):
        if request.matchdict is not None and request.matchdict != "":
            content.update(request.matchdict)
    return content
