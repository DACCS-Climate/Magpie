from pyramid.httpexceptions import *
from sys import exc_info
import types

# control variables to avoid infinite recursion in case of
# major programming error to avoid application hanging
RAISE_RECURSIVE_SAFEGUARD_MAX = 5
RAISE_RECURSIVE_SAFEGUARD_COUNT = 0


def verify_param(param, paramCompare=None, httpError=HTTPNotAcceptable, msgOnFail="",
                 notNone=False, notEmpty=False, notIn=False,
                 isNone=False, isEmpty=False, isIn=False):
    """
    Evaluate various parameter combinations given the requested flags.
    Given a failing verification, directly raises the specified `httpError`.
    Invalid exceptions generated by this verification process are treated as `HTTPInternalServerError`.
    Exceptions are generated using the standard output method.

    :param param: (bool) parameter value to evaluate
    :param paramCompare:
        other value(s) to test against, should be an iterable (otherwise resolved as one unless None)
        to test for None type, use `isNone`/`notNone` flags instead or `paramCompare`=[None]
    :param httpError: (HTTPError) derived exception to raise on test failure (default: `HTTPNotAcceptable`)
    :param msgOnFail: (str) message details to return in HTTP exception if flag condition failed
    :param notNone: (bool) test that `param` is None type
    :param notEmpty: (bool) test that `param` is an empty string
    :param notIn: (bool) test that `param` does not exist in `paramCompare` values
    :param isNone: (bool) test that `param` is None type
    :param isEmpty: (bool) test `param` for an empty string
    :param isIn: (bool) test that `param` exists in `paramCompare` values
    :raises `HTTPError`: if tests fail, specified exception is raised (default: `HTTPNotAcceptable`)
    :raises `HTTPInternalServerError`: for evaluation error
    :return: nothing if all tests passed
    """
    # precondition evaluation of input parameters
    try:
        if type(notNone) is not bool:
            raise Exception("'notNone' is not a 'bool'")
        if type(notEmpty) is not bool:
            raise Exception("'notEmpty' is not a 'bool'")
        if type(notIn) is not bool:
            raise Exception("'notIn' is not a 'bool'")
        if type(isNone) is not bool:
            raise Exception("'isNone' is not a 'bool'")
        if type(isEmpty) is not bool:
            raise Exception("'isEmpty' is not a 'bool'")
        if type(isIn) is not bool:
            raise Exception("'isIn' is not a 'bool'")
        if paramCompare is not None and not hasattr(paramCompare, '__iter__'):
            paramCompare = [paramCompare]
        if len(paramCompare) < 1:
            raise Exception("'paramCompare' is empty")
    except Exception as e:
        raise_http(httpError=HTTPInternalServerError, detail=repr(e),
                   content={'traceback': repr(exc_info())})

    # evaluate requested parameter combinations
    if (notNone and param is None) or (isNone and param is not None) \
    or (notEmpty and param == "") or (isEmpty and not param == "") \
    or (notIn and param in paramCompare) or (isIn and param not in paramCompare):
        raise_http(httpError, detail=msgOnFail, content={'param': repr(param)})


def evaluate_call(call, fallback=None, httpError=HTTPInternalServerError, msgOnFail=""):
    """
    Evaluates the specified `call` with a wrapped HTTP exception handling.
    On failure, tries to call `fallback` if specified, and finally raises the specified `httpError`.
    Any potential error generated by `fallback` or `httpError` themselves are treated as `HTTPInternalServerError`.
    Exceptions are generated using the standard output method.

    Example:
        normal call:
            ```
            try:
                res = func(args)
            except Exception as e:
                fb_func()
                raise HTTPExcept(e.message)
            ```
        wrapped call:
            ```
            res = evaluate_call(lambda: func(args), fallback=lambda: fb_func(), httpError=HTTPExcept, msgOnFail="...")
            ```

    :param call: function to call, *MUST* be specified as `lambda: <function_call>`
    :param fallback: function to call (if any) when `call` failed, *MUST* be `lambda: <function_call>`
    :param httpError: (HTTPError) alternative exception to raise on `call` failure
    :param msgOnFail: (str) message details to return in HTTP exception if `call` failed
    :raises httpError: on `call` failure
    :raises `HTTPInternalServerError`: on `fallback` failure
    :return: whichever return value `call` might have if no exception occurred
    """
    msgOnFail = repr(msgOnFail) if type(msgOnFail) is not str else msgOnFail
    if not islambda(call):
        raise_http(httpError=HTTPInternalServerError,
                   detail="Input `call` is not a lambda expression")
    try:
        return call()
    except Exception as e:
        ce = repr(e)
    try:
        if fallback is not None:
            if islambda(fallback):
                fallback()
            else:
                raise_http(httpError=HTTPInternalServerError,
                           detail="Input `fallback`  is not a lambda expression",
                           content={'call': {'exception': ce},
                                    'detail': msgOnFail})
    except Exception as e:
        fe = repr(e)
        raise_http(httpError=HTTPInternalServerError,
                   detail="Fallback from `call` exception failed",
                   content={'call': {'exception': ce},
                            'fallback': {'exception': fe},
                            'detail': msgOnFail})
    raise_http(httpError, detail=msgOnFail, content={'call': {'exception': ce}})


def islambda(func):
    return isinstance(func, types.LambdaType) and func.__name__ == (lambda: None).__name__


def isclass(obj):
    """
    Evaluate an object for class type (ie: class definition, not an instance nor any other type).

    :param obj: object to evaluate for class type
    :return: (bool) indicating if `object` is a class
    """
    return isinstance(obj, (type, types.ClassType))


def raise_http(httpError=HTTPInternalServerError, detail="", content=None, contentType='application/json'):
    """
    Raises an HTTP exception with standardized information formatted with content type.
    The content contains the corresponding http error code, the provided message as detail and
    optional specified additional json content (kwarg dict).

    :param httpError: any derived class from base `HTTPError` (default: HTTPInternalServerError)
    :param detail: additional message information (default: empty)
    :param content: json formatted content to include
    :param contentType: format in which to return the exception ('application/json', 'text/html' or 'text/plain')
    :raises `HTTPError`: formatted raised exception with additional details and HTTP code
    """
    # fail-fast if recursion generates too many calls
    # this would happen only if a major programming error occurred within this function
    global RAISE_RECURSIVE_SAFEGUARD_MAX
    global RAISE_RECURSIVE_SAFEGUARD_COUNT
    RAISE_RECURSIVE_SAFEGUARD_COUNT = RAISE_RECURSIVE_SAFEGUARD_COUNT + 1
    if RAISE_RECURSIVE_SAFEGUARD_COUNT > RAISE_RECURSIVE_SAFEGUARD_MAX:
        raise HTTPInternalServerError(detail="Terminated. Too many recursions of `raise_http`")

    # verify input arguments, raise `HTTPInternalServerError` with caller info if invalid
    # cannot be done within a try/except because it would always trigger with `raise_http`
    content = dict() if content is None else content
    detail = repr(detail) if type(detail) is not str else detail
    if not isclass(httpError):
        raise_http(httpError=HTTPInternalServerError,
                   detail="Object specified is not of type `HTTPError`",
                   contentType='application/json',
                   content={'caller': {'content': content,
                                       'detail': detail,
                                       'code': 520,  #'unknown' error
                                       'type': contentType}})
    httpCode = httpError.code if issubclass(httpError, HTTPException) else 'n/a'
    if not issubclass(httpError, HTTPError):
        raise_http(httpError=HTTPInternalServerError,
                   detail="Invalid `HTTPError` derived class specified",
                   contentType='application/json',
                   content={'caller': {'content': content,
                                       'detail': detail,
                                       'code': httpCode,
                                       'type': contentType}})
    if contentType not in ['application/json', 'text/html', 'text/plain']:
        raise_http(httpError=HTTPInternalServerError,
                   detail="Invalid `contentType` specified for exception output",
                   contentType='application/json',
                   content={'caller': {'content': content,
                                       'detail': detail,
                                       'code': httpCode,
                                       'type': contentType}})

    # try dumping content with json format, `HTTPInternalServerError` with caller info if fails.
    # content is added manually to avoid auto-format and suppression of fields by `HTTPException`
    json_body = {}
    try:
        content['code'] = httpError.code
        content['detail'] = detail
        content['type'] = contentType
        json_body = json.dumps(content)
    except Exception as e:
        msg = "Dumping json content [" + str(content) + \
              "] resulted in exception [" + repr(e) + "]"
        raise_http(httpError=HTTPInternalServerError, detail=msg,
                   contentType='application/json',
                   content={'traceback': repr(exc_info()),
                            'caller': {'content': repr(content),   # raw string to avoid recursive json.dumps error
                                       'detail': detail,
                                       'code': httpError.code,
                                       'type': contentType}})

    # directly output json if asked with 'application/json'
    if contentType == 'application/json':
        raise httpError(
            body=json_body,
            content_type='application/json'
        )
    # otherwise json is contained within the html <body> section
    if contentType == 'text/html':
        raise httpError(
            # add preformat <pre> section to output as is within the <body> section
            body_template=httpError.explanation + "<br><h2>Exception Details</h2>" +
                          "<pre style='word-wrap: break-word; white-space: pre-wrap;'>" +
                          json_body + "</pre>",
            content_type='text/html'
        )
    # default back to 'text/plain'
    raise httpError(
        body=json_body,
        content_type='text/plain'
    )


def return_http(httpSuccess=HTTPSuccessful, detail="", content=None, type='application/json'):
    pass
