from pyramid.httpexceptions import *
from sys import exc_info


def verify_param(param, paramCompare=None, httpException=HTTPNotAcceptable, msgOnFail="",
                 notNone=False, notEmpty=False, notIn=False,
                 isNone=False, isEmpty=False, isIn=False):
    """
    Evaluate various parameter combinations given the requested flags.
    Given a failing verification, directly raises the specified `httpException`.
    Invalid exceptions generated by this verification process are treated as `HTTPInternalServerError`.
    Exceptions are generated using the standard output method.

    :param param: (bool) parameter value to evaluate
    :param paramCompare:
        other value(s) to test against, should be an iterable (otherwise resolved as one unless None)
        to test for None type, use `isNone`/`notNone` flags instead or `paramCompare`=[None]
    :param httpException: (HTTPException) alternative exception to raise on test failure (default: HTTPNotAcceptable)
    :param msgOnFail: (str) message details to return in HTTP exception if flag condition failed
    :param notNone: (bool) test that `param` is None type
    :param notEmpty: (bool) test that `param` is an empty string
    :param notIn: (bool) test that `param` does not exist in `paramCompare` values
    :param isNone: (bool) test that `param` is None type
    :param isEmpty: (bool) test `param` for an empty string
    :param isIn: (bool) test that `param` exists in `paramCompare` values
    :raises HTTPException: if tests fail, specified exception is raised (default: HTTPNotAcceptable)
    :raises HTTPInternalServerError: for evaluation error
    :return: nothing if all tests passed
    """
    # precondition evaluation of input parameters
    try:
        if type(notNone) is not bool:
            raise Exception("'notNone' is not a 'bool'")
        if type(notEmpty) is not bool:
            raise Exception("'notEmpty' is not a 'bool'")
        if type(notIn) is not bool:
            raise Exception("'notIn' is not a 'bool'")
        if type(isNone) is not bool:
            raise Exception("'isNone' is not a 'bool'")
        if type(isEmpty) is not bool:
            raise Exception("'isEmpty' is not a 'bool'")
        if type(isIn) is not bool:
            raise Exception("'isIn' is not a 'bool'")
        if paramCompare is not None and not hasattr(paramCompare, '__iter__'):
            paramCompare = [paramCompare]
        if len(paramCompare) < 1:
            raise Exception("'paramCompare' is empty")
    except Exception as e:
        raise_http_json(httpException=HTTPInternalServerError, detail=repr(e),
                        json_content={'traceback': repr(exc_info())})

    # evaluate requested parameter combinations
    if (notNone and param is None) or (isNone and param is not None) \
    or (notEmpty and param == "") or (isEmpty and not param == "") \
    or (notIn and param in paramCompare) or (isIn and param not in paramCompare):
        raise_http_json(httpException, detail=msgOnFail, json_content={'param': repr(param)})


def evaluate_call(call, fallback=None, httpException=HTTPInternalServerError, msgOnFail=""):
    """
    Evaluates the specified `call` with a wrapped HTTP exception handling.
    On failure, tries to call `fallback` if specified, and finally raises the specified `httpException`.
    Any potential error generated by `fallback` or `httpException` themselves are treated as `HTTPInternalServerError`.
    Exceptions are generated using the standard output method.

    Example:
        normal call:
            ```
            result = function(arg)
            ```
        wrapped call:
            ```
            result = evaluate_call(lambda: function(arg))
            ```

    :param call: function to call, *MUST* be specified as `lambda: <function_call>`
    :param fallback: function to call (if any) when `call` failed, *MUST* be `lambda: <function_call>`
    :param httpException: (HTTPException) alternative exception to raise on `call` failure
    :param msgOnFail: (str) message details to return in HTTP exception if `call` failed
    :raises httpException: on `call` failure
    :raises HTTPInternalServerError: on `fallback` failure
    :return: whichever return value `call` might have if no exception occurred
    """
    if not islambda(call):
        raise_http_json(httpException=HTTPInternalServerError,
                        detail="Input `call` is not a lambda expression")
    try:
        return call()
    except Exception as e:
        ce = repr(e)
    try:
        if fallback is not None:
            if islambda(fallback):
                fallback()
            else:
                raise_http_json(httpException=HTTPInternalServerError,
                                detail="Input `fallback`  is not a lambda expression",
                                json_content={'call': {'exception': ce},
                                              'detail': repr(msgOnFail)})
    except Exception as e:
        fe = repr(e)
        raise_http_json(httpException=HTTPInternalServerError,
                        detail="Fallback from `call` exception failed",
                        json_content={'call': {'exception': ce},
                                      'fallback': {'exception': fe},
                                      'detail': repr(msgOnFail)})
    raise_http_json(httpException, detail=msgOnFail, json_content={'call': {'exception': ce}})


def islambda(func):
    LAMBDA = lambda: None
    return isinstance(func, type(LAMBDA)) and func.__name__ == LAMBDA.__name__


def raise_http_json(httpException=HTTPInternalServerError, detail="", json_content=None):
    """
    Raises an HTTP exception with standardized information formatted with json content.
    The json contains the corresponding http error code, the provided message as detail,
    optional additional json content and the content type (ie: application/json).

    :param httpException: any derived class from base `HTTPException` (default: HTTPInternalServerError)
    :param detail: additional message information (default: empty)
    :param json_content: json formatted content to include
    :raises HTTPException: formatted raised exception with additional details and HTTP code
    """
    if json_content is None:
        json_content = {}
    if not issubclass(httpException, HTTPException):
        raise_http_json(httpException=HTTPInternalServerError,
                        detail="Invalid HTTPException specified",
                        json_content={'json_content': json_content, 'detail': detail})
    json_body = {}
    try:
        json_body = json.dumps(json_content)
    except Exception as e:
        msg = "Dumping json content [" + str(json_content) + \
              "] resulted in exception [" + repr(e) + "]"
        raise_http_json(httpException=HTTPInternalServerError, detail=msg,
                        json_content={'traceback': repr(exc_info())})
    raise httpException(
        code=httpException.code,
        body=json_body,
        detail=detail,
        content_type='application/json'
    )


